= Rubyへの部分世代別GCの実装

= 概要
オブジェクト指向スクリプト言語Rubyは現在多くの場面で使用されている．大
規模なWebアプリケーションが実はRubyで作成されていたというのは珍しくな
い．
しかし，ある程度大規模なアプリケーションになると実行速度が遅くなるとい
う問題があり，その原因の一つとしてGCの処理速度が上げられる．
RubyにはシンプルなマークアンドスイープGCが実装されている．だが，マーク
アンドスイープはオブジェクト数に比例して処理速度が遅くなるアルゴリズム
である．大規模なアプリケーションでは必然的にオブジェクト数が多くなり，
マークスイープの処理速度は低下し，アプリケーションの実行時間は遅くな
る．
この対策として広く知られているのが世代別GCというアルゴリズムである．世
代別GCでは多くあるオブジェクトの中の長寿命なものを特別に扱い，マークア
ンドスイープGCの処理速度の低下を防ぐ．
そこで代表的なRubyのWebフレームワークであるRubyOnRailsアプリケーション
でのヒープの使用状態を詳しく調査した所，Rubyヒープ内を多くの占めている
特定のオブジェクトが長寿命であることが分かった．
本研究ではその長寿命なオブジェクトに着目し，RubyGCに部分的な世代別GCを
導入し，マークアンドスイープの高速化を目指す．

= はじめに
オブジェクト指向スクリプト言語Rubyは現在多くの場面で使用されています．
特に近年，RubyOnRailsという便利なWebフレームワークが登場し，Webアプリ
ケーションの分野で多く使われています．

= 問題提起

== Rubyの問題点
大規模なアプリケーションの場合，Ruby自体の処理速度が問題になる事があり
ます．その原因としてGCの処理速度が上げられます．
RubyGCにはシンプルなマークアンドスイープGCが実装されています．このアル
ゴリズムはオブジェクト数に比例して処理速度が遅くなるアルゴリズムでで
す．大規模なアプリケーションでは必然的にオブジェクト数が多くなり，マー
クスイープの処理速度は低下し，アプリケーションの実行時間は遅くなってし
まいます．

== Rubyメモリ使用状況の調査
Railsのアプリケーションでのメモリ使用状態を調べた所，おもしろい事実が
分かりました．
Rubyのヒープ内に構文木のオブジェクト（T_NODE）が平均してヒープ内の50％
以上を占めているという事が分かったのです．
以下は，ヒープ内を占有していたオブジェクトの順位とそのおおまかな占有量です．

(1) 構文木オブジェクト（T_NODE）         : 40%
(2) 文字列オブジェクト（T_STRING）       : 40%
(3) 配列（T_ARRAY）                   : 4%
(4) 拡張ライブラリオブジェクト（T_DATA）  : 4%
（TODO：グラフが必要）

私はこの結果を不思議に思いました．

なぜなら，多くの構文木オブジェクトはYARV命令列にコンパイルしてしまえば
不要であり，自然と構文木はGCによって削除されるはずで，構文木オブジェク
トはヒープ内にはごく少数しかないのではないかと思ったからです．

== 大量の構文木オブジェクト存在の理由
ヒープ内に多く見られた構文木オブジェクトの種類を大まかな割合と共に以下
に列挙します．
(1) NODE_WHILE  : 50%
(2) NODE_METHOD : 20%
(3) NODE_FBODY  : 13%
(4) NODE_BLOCK  : 10%
(5) NODE_CFUNC  : 5%
(6) NODE_ARRAY  : 2%
（TODO：グラフが必要）

これらの構文木オブジェクトが生成されるタイミングを見ると，どうやらYARV
命令列にコンパイルするタイミングではない部分で使用されているようです．

この事から，YARV命令列にコンパイルされた構文木オブジェクトに関しては予
想通り破棄されていそうですが，それ以外の部分で使用された構文木オブジェク
トがヒープ内に多く生存しているのではないかと考えました．

そこで，多く生存していた構文木オブジェクトの種類毎に，その構文木がどの
タイミングで生成され，どのように使用されているのか，さらに調査を行いま
した．

=== NODE_WHILE
一番多かった NODE_WHILE 構文木オブジェクトですが，その多くがVM内部のイ
ンラインキャッシュに使用されているという事が分かりました．
YARVでは以下の様なインラインキャッシュが行われています．

(1)インラインメソッドキャッシュ
(2)定数インラインキャッシュ

=== NODE_METHOD, NODE_FBODY, NODE_CFUNC
NODE_METHODとNODE_FBODY構文木オブジェクトですが，これは各クラスのメソッ
ドテーブルに登録されています．
Rubyでは各クラスに

 class Foo
   def bar
     "Hellow world"
   end
 end

という形でメソッドを定義しますが，この際に内部的にNODE_METHODと
NODE_FBODYが生成されています．

また，Ruby内部のほとんどのメソッドがCレベルでメソッド定義されています．
Cレベルでメソッド定義する際には以下の様なAPIを使用します．

 rb_define_method(rb_cArray, "initialize", rb_ary_initialize, -1);
 rb_define_method(rb_cArray, "initialize_copy", rb_ary_replace, 1);

この際に，関数の情報と引数の情報を保持するNODE_CFUNC構文木オブジェクト
が内部的に生成されます．

=== NODE_BLOCK
NODE_BLOCK構文木オブジェクトですが，その多くはVM内部でベースクラスの保
持に使用されているものだと言う事が分かりました．

 class Base
   class Child
   end
 end

上記の様なコードで Base クラスは Child クラスのベースクラスになりま
す．この際にRuby内部ではNODE_BLOCKが生成されます．

== 構文木オブジェクトに共通する点
Rubyヒープ内の半分は構文木オブジェクトに占められており，それらを個別に
詳しく調査するとほとんどの構文木オブジェクトはメソッドの定義などの長生
きするオブジェクトである事が分かりました．

= 改善案

== 長寿命オブジェクトに対する一般的なアプローチ
マークアンドスイープGCの処理速度を向上させる改善手法に世代別GCというも
のがあります．
オブジェクトには人間と同じようにそれぞれに寿命があります．例えば，ロー
カル変数で保持しているオブジェクトはすぐに不要になる（短命）でしょう
し，定数が保持するオブジェクトはずっと使用し続ける（長寿命）はずです．
寿命の観点でGCを考えてみると，長寿命なオブジェクトに対して毎回GC対象と
するのは不自然に感じます．なぜなら，そのオブジェクトは長寿命であり，GC
される確率が非常にすくないからです．
そこで長寿命なオブジェクトに関しては毎回GCの対象とするのではなく，数回
に一回GCを行おうと考えました．これが世代別GCの考え方です．
シンプルに世代別GCを実装する場合，新しいオブジェクトのNew領域と古いオ
ブジェクトのOld領域にヒープを分割します．
すべてのオブジェクトは最初New領域に属していますが，GCに特定の回数生き
残ったオブジェクトは長寿命であると見なし，Old領域に移動します．
通常のGCではNew領域のみを対象とし，Old領域に関してはGC対象としません．
これによって，オブジェクトのライフサイクルにあったタイミングでメモリ解
放を行える為，より効率的にGCを行えるようになります．
（TODO：図が必要）

== Rubyへの世代別GC実装の困難性
素直にRubyeに世代別GCを実装する場合，問題となる点にライトバリアの挿入
があります．
世代別GCではOld領域をGC対象としないため，Old領域のオブジェクトからNew
領域への参照があった場合，New領域の生きているはずのオブジェクトが死んで
いるオブジェクトと見なされ，解放されてしまう恐れがあります．
その為，世代別GCにはライトバリアという機能を入れるのが一般的です．
ライトバリアにはOld世代からNew世代への参照が記録されます．New世代でマー
クを行う際にライトバリアで記録した参照も辿ってマークしていきます．これ
によって生きているオブジェクトが解放される事はなくなります．
（TODO：図の挿入）
（TODO：ライトバリアのコード例）
しかし，全てのオブジェクトの参照の切替時にライトバリアを張らなければなら
ず，これまでの既存のコード全てにライトバリアの挿入するのは非常にコスト
がかかり，非現実的です．
また，Rubyの場合，多くのCの拡張ライブラリがあります．拡張ライブラリ作
者に対してオブジェクトのライトバリアを強要する事になり，拡張ライブラリ
作成の容易さを妨げてしまいます．

== Rubyへの一部世代別GCの提案
今回，私が提案する一部世代別GCのアイデアは，Rubyメモリ使用状況の調査の
章で説明したヒープ内を占めていた長寿命な構文木オブジェクトに注目し，そ
のような構文木オブジェクトについては初めからOld領域に割り当ててしまう
事にします．
これにより，Rubyヒープ内の約半分を占めていた構文木オブジェクトに対する
マークの手間が減り，GCの実行時間を短縮できます．
（TODO：図が必要）
また，問題であったライトバリアの挿入ですが，提案手法では構文木オブジェ
クトでかつ特定の種類もののみOld領域に格納し，文字列や配列などの通常のオ
ブジェクトに関してはOld領域に移動させません．
これにより，特定の限られた部分にのみライトバリアを挿入するだけで済
み，Ruby内部の多くのコードを書き換えずに済み，導入が容易です．
また，RubyのCの拡張ライブラリへのライトバリア挿入ですが，構文木オブジェ
クトは拡張ライブラリでは滅多な事では使用されませんので，拡張ライブラリ
へのライトバリアの挿入も容易であると考えています．
（TODO：図が必要）

= 世の中への出し方
作成したコードはもちろんRubyに取り込んでいただけるように努力します．
その為に，改善の結果を正しく測定し，正しいドキュメントを書き，コミッタ
の皆さんとまつもとさんの納得して貰えるだけの資料を作成したいと思ってお
ります．
うまくRubyに取り込まれれば，私が行った改善は全世界のRubyで構築された
Webアプリケーションの実行速度を上げてくれるでしょう．

= 斬新さの主張
（TODO：まとめ）
* 誰も気づいていない点について（構文木オブジェクトが多い）
* 誰も発想していない改善（RubyGCにおいて）
* そもそもRubyのGCをいじる発想があるか
* よりアプリケーション向きの改善であるという点

= 期待される効果
期待される効果として，RubyGCの実行速度が速くなるという点しかありませ
ん．それだけか？と言わればそうなのですが，これ程，明確な効果もないので
はないかと思います．RubyGCの実行速度が0.1秒でも高速化されれば，世界中
のRubyユーザの0.1秒を無駄に使わずに済むわけですから，これはとても名誉
な事だと考えています．

= 具体的な進め方と予算
（TODO：スケジュールとか）
(1) 主に開発を行う場所
(2) 使用する計算機環境(ハード、OS)
(3) 使用する言語・ツール
(4) 共同開発者がいる場合は、作業の分担
(5) (もしあれば) ソフトウェア開発に使う手法
(6) 開発線表―― いつまでになにをやるか、手順と時期(月単位) を明確に書
いたもの
(7) 開発にかかわる時間帯と時間数―― 毎週どのような時間帯に開発を行うかを
おおまかに書いてください。学生、組織人の場合、フルタイムの開発は難しいでし
ょうから。また、開発フェーズで変動する場合は、簡単にリマークしておいてくだ
さい。たとえば、7 月は本業や試験で開店休業だが、8 月は普段の2 倍集中するな
ど。
(8) (もしあれば) 外注の内容、予算、想定している外注先(未定でもよい)
(9) 購入する備品とその使途―― これはなるべくきちんと書いてください。IPA
もこのあたりいろいろチェックします。
(10) 予算内訳をまとめた表―― プロジェクト管理組織の費用として、一律50 万
円を組み込むことを忘れないでください。その残りの予算の多くの部分を開発者の
人件費にしても構いません。未踏ユースでは開発者1 名の人件費は1 時間あたり一
律2,000 円です。この基準に合わせて積算をしてください。そのほか、PC 等の購
入についてはいろいろな縛りがあります。予算の詳細は、採択されてからの契約時
にプロジェクト管理組織やPM と相談して調整することになります。

= 今までに作成したコード
このURLにまとめております．
((<URL: http://www.narihiro.info/>))

= ソフトウェア以外の趣味など
* サッカー
* スノーボード
（TODO：まとめ）

= 将来のソフトウェア技術について思うこと
* Web時代
* もっと低レベルな事をやろう
* 最終的に生き残るのは低レベルな事をやった人
（TODO：まとめ）

= おわりに
なお，この提案はRuby開発者のまつもとさんのアドバイスを受けて，私が調
査，発案したものです．この場をかりてまつもとさんに感謝したいと思いま
す．
（TODO：まとめ）
