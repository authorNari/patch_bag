= Rubyへの部分世代別GCの実装

= 概要
オブジェクト指向スクリプト言語Rubyは現在多くの場面で使用されている．大
規模なWebアプリケーションが実はRubyで作成されていたというのは珍しくな
い．
しかし，ある程度大規模なアプリケーションになると実行速度が遅くなるとい
う問題があり，その原因の一つとしてGCの処理速度が上げられる．
RubyにはシンプルなマークアンドスイープGCが実装されている．だが，マーク
アンドスイープはオブジェクト数に比例して処理速度が遅くなるアルゴリズム
である．大規模なアプリケーションでは必然的にオブジェクト数が多くなり，
マークスイープの処理速度は低下し，アプリケーションの実行時間は遅くな
る．
この対策として広く知られているのが世代別GCというアルゴリズムである．世
代別GCでは多くあるオブジェクトの中の長寿命なものを特別に扱い，マークア
ンドスイープGCの処理速度の低下を防ぐ．
そこで代表的なRubyのWebフレームワークであるRubyOnRailsアプリケーション
でのヒープの使用状態を詳しく調査した所，Rubyヒープ内を多くの占めている
特定のオブジェクトが長寿命であることが分かった．
本研究ではその長寿命なオブジェクトに着目し，RubyGCに部分的な世代別GCを
導入し，マークアンドスイープの高速化を目指す．

= はじめに
オブジェクト指向スクリプト言語Rubyは現在多くの場面で使用されています．
特に近年，RubyOnRailsという便利なWebフレームワークが登場し，Webアプリ
ケーションの分野で多く使われています．

= 問題提起

== Rubyの問題点
大規模なアプリケーションの場合，Ruby自体の処理速度が問題になる事があり
ます．その原因としてGCの処理速度が上げられます．
RubyGCにはシンプルなマークアンドスイープGCが実装されています．このアル
ゴリズムはオブジェクト数に比例して処理速度が遅くなるアルゴリズムでで
す．大規模なアプリケーションでは必然的にオブジェクト数が多くなり，マー
クスイープの処理速度は低下し，アプリケーションの実行時間は遅くなってし
まいます．

== Rubyメモリ使用状況の調査
Railsのアプリケーションでのメモリ使用状態を調べた所，おもしろい事実が
分かりました．
Rubyのヒープ内に構文木のオブジェクト（T_NODE）が平均してヒープ内の50％
以上を占めているという事が分かったのです．
以下は，ヒープ内を占有していたオブジェクトの順位とそのおおまかな占有量です．

(1) 構文木オブジェクト（T_NODE）         : 40%
(2) 文字列オブジェクト（T_STRING）       : 40%
(3) 配列（T_ARRAY）                   : 4%
(4) 拡張ライブラリオブジェクト（T_DATA）  : 4%

私はこの結果を不思議に思いました．

なぜなら，多くの構文木オブジェクトはYARV命令列にコンパイルしてしまえば
不要であり，自然と構文木はGCによって削除されるはずで，構文木オブジェク
トはヒープ内にはごく少数しかないのではないかと思ったからです．

== 大量の構文木オブジェクト存在の理由
ヒープ内に多く見られた構文木オブジェクトの種類を大まかな割合と共に以下
に列挙します．
(1) NODE_WHILE  : 50%
(2) NODE_METHOD : 20%
(3) NODE_FBODY  : 13%
(4) NODE_BLOCK  : 10%
(5) NODE_CFUNC  : 5%
(6) NODE_ARRAY  : 2%

これらの構文木オブジェクトが生成されるタイミングを見ると，どうやらYARV
命令列にコンパイルするタイミングではない部分で使用されているようです．

この事から，YARV命令列にコンパイルされた構文木オブジェクトに関しては予
想通り破棄されていそうですが，それ以外の部分で使用された構文木オブジェク
トがヒープ内に多く生存しているのではないかと考えました．

そこで，多く生存していた構文木オブジェクトの種類毎に，その構文木がどの
タイミングで生成され，どのように使用されているのか，さらに調査を行いま
した．

=== NODE_WHILE
一番多かった NODE_WHILE 構文木オブジェクトですが，その多くがVM内部のイ
ンラインキャッシュに使用されているという事が分かりました．
YARVでは以下の様なインラインキャッシュが行われています．

(1)インラインメソッドキャッシュ
(2)定数インラインキャッシュ

=== NODE_METHOD, NODE_FBODY, NODE_CFUNC
NODE_METHODとNODE_FBODY構文木オブジェクトですが，これは各クラスのメソッ
ドテーブルに登録されています．
Rubyでは各クラスに

 class Foo
   def bar
     "Hellow world"
   end
 end

という形でメソッドを定義しますが，この際に内部的にNODE_METHODと
NODE_FBODYが生成されています．

また，Ruby内部のほとんどのメソッドがCレベルでメソッド定義されています．
Cレベルでメソッド定義する際には以下の様なAPIを使用します．

 rb_define_method(rb_cArray, "initialize", rb_ary_initialize, -1);
 rb_define_method(rb_cArray, "initialize_copy", rb_ary_replace, 1);

この際に，関数の情報と引数の情報を保持するNODE_CFUNC構文木オブジェクト
が内部的に生成されます．

=== NODE_BLOCK
NODE_BLOCK構文木オブジェクトですが，その多くはVM内部でベースクラスの保
持に使用されているものだと言う事が分かりました．

 class Base
   class Child
   end
 end

上記の様なコードで Base クラスは Child クラスのベースクラスになりま
す．この際にRuby内部ではNODE_BLOCKが生成されます．

=== 構文木オブジェクトに共通する点
Rubyヒープ内の半分は構文木オブジェクトに占められており，それらを個別に
詳しく調査するとほとんどの構文木オブジェクトはメソッドの定義などの長生
きするオブジェクトである事が分かりました．

= 改善案

== 長寿命オブジェクトに対する一般的なアプローチ
マークアンドスイープGCの処理速度を向上させる改善手法に世代別GCというも
のがあります．
オブジェクトには人間と同じようにそれぞれに寿命があります．例えば，ロー
カル変数で保持しているオブジェクトはすぐに不要になる（短命）でしょう
し，定数が保持するオブジェクトはずっと使用し続ける（長寿命）はずです．
寿命の観点でGCを考えてみると，長寿命なオブジェクトに対して毎回GC対象と
するのは不自然に感じます．なぜなら，そのオブジェクトは長寿命であり，GC
される確率が非常にすくないからです．
そこで長寿命なオブジェクトに関しては毎回GCの対象とするのではなく，数回
に一回GCを行おうと考えました．これが世代別GCの考え方です．

=== Rubyへの世代別GC実装の困難性

=== 
